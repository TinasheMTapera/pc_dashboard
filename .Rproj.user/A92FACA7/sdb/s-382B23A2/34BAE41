{
    "collab_server" : "",
    "contents" : "#requirements\nrequire(tidyverse) #tidy programming\nrequire(lubridate) #easy working with datetimes\nSys.setenv(TZ=\"America/New_York\")\n\n# wrapper function to unzip a file and place the result in a directory \"data\"\nUnzip_Data = function(zip_file){\n  unzip(zipfile = zip_file, overwrite = TRUE, exdir = \"./data\")\n  list.files(\"./data\")%>%\n    .[1]%>%\n    return()\n}\n\n#adds a zero to single digit values for time parsing\nAdd_Zero = function(string){\n  string=string%>%\n    as.character()%>%\n    as.numeric()\n  ifelse(string < 10, paste0(\"0\",string), string)%>%\n    return()\n}\n\n#split a column with many checked items into a matrix with each item checked\nSplit_CheckBoxes = function(column, name){\n  \n  #first, get all the items\n  column = as.character(column)\n  categories = NULL\n  for(line in 1:length(column)){\n    items = strsplit(column[line], split=\",\")%>%unlist()\n    categories = c(categories,items)\n  }\n  categories = unique(categories)\n  \n  #create an empty dataframe\n  toReturn = data.frame(matrix(nrow = length(column), \n                               ncol = length(categories)))\n  \n  #loop by row of original data, and then by column of categories, \n  #checking if each row has the category\n  \n  for(line in 1:length(column)){\n    for(x in 1:length(categories)){\n      toReturn[line,x] = ifelse(grepl(categories[x],column[line]), 1,0)\n    }\n  }\n  \n  names(toReturn) = paste0(name,\".\",gsub(\" \", \"_\", categories))\n  \n  return(toReturn)\n}\n\n# Load and clean a file of call logs from Qualtrics\nLoad_Data = function(f){\n  \n  tryCatch({\n    #read in the dataset\n    #f = list.files(\"./data\")[1]\n    dat = read.csv(f,fill=TRUE)\n    \n    #special case\n    if(nrow(dat) < 2){\n      return()\n    }\n    \n    #get survey questions\n    questions = dat[1,]%>%\n      t()%>%\n      as.character()\n    \n    #remove junk rows from qualtrics\n    dat = dat[-c(1,2),]\n    dat = dat%>%\n      filter(Finished == \"True\" | Finished == \"TRUE\")\n    \n    #convert datetimes for call start and end\n    call_start = strptime(\n      paste0(\n        as.character(dat$start_date), \" \",\n        Add_Zero(dat$start_time_1), \":\",\n        Add_Zero(dat$start_time_2), \" \",\n        toupper(as.character(dat$start_time_3))\n      ),\n      format = \"%m-%d-%Y %I:%M %p\", \n      tz = \"America/New_York\")\n    \n    call_end = strptime(\n      paste0(\n        as.character(dat$end_date), \" \",\n        Add_Zero(dat$end_time_1), \":\",\n        Add_Zero(dat$end_time_2), \" \",\n        toupper(as.character(dat$end_time_3))\n      ), \n      format = \"%m-%d-%Y %I:%M %p\", \n      tz = \"America/New_York\")\n    \n    #record when log was submitted\n    submitted = ymd_hms(dat$RecordedDate, tz = \"UTC\")\n    \n    #only take columns from relevant call info onwards\n    start_column = names(dat)%>%\n      grep(\"primary\",.,value=FALSE)%>%\n      .[1]\n    dat = dat[,start_column:ncol(dat)]\n    \n    #refactor\n    body_ind =  names(dat)%>%\n      grep(\"body\",.,value=FALSE)%>%\n      .[1]\n    dat[,-body_ind] = droplevels.data.frame(dat[,-body_ind])\n    dat[,body_ind] = as.character(dat[,body_ind])\n    \n    feedback_ind = names(dat)%>%\n      grep(\"opinion\",.,value=FALSE)%>%\n      .[1]\n    dat[,feedback_ind] = as.character(dat[,feedback_ind])\n    \n    checkboxes = names(dat)%>%\n      grep(\"issues|skills|referrals|marketing\",.,value = TRUE)\n    \n    for(i in 1:length(checkboxes)){\n      \n      if(length(levels(dat[,checkboxes[i]])) < 2){\n        dat[,checkboxes[i]] = NULL\n        next()\n      }\n      \n      dat = cbind(dat, Split_CheckBoxes(dat[,checkboxes[i]], checkboxes[i]))\n      dat[,checkboxes[i]] = NULL\n    }\n    \n    cbind(submitted, call_start, call_end, dat)%>%\n      return()\n  }, \n  error = function(err){\n    print(\"Load data error! Check that this is the correct file type!\")\n    return(NULL)\n  })\n  \n}\n\n\n#get the earliest call start time\ngetMin = function(df){\n  df%>%\n    select(call_start)%>%\n    slice(which.min(call_start))%>%\n    .$call_start%>%\n    floor_date(\"month\")%>%\n    return()\n}\n\ngetMax = function(df){\n  df%>%\n    select(call_start)%>%\n    slice(which.max(call_start))%>%\n    .$call_start%>%\n    ceiling_date(\"month\")%>%\n    return()\n}\n\n",
    "created" : 1528320222864.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1878442645",
    "id" : "34BAE41",
    "lastKnownWriteTime" : 1528284965,
    "last_content_update" : 1528284965,
    "path" : "~/Google Drive/DataScience/pc_dashboard/NewDataSet.R",
    "project_path" : "NewDataSet.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}